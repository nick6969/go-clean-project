// Code generated by MockGen. DO NOT EDIT.
// Source: login.go
//
// Generated by this command:
//
//	mockgen -source=login.go -destination=./login_mock_test.go -package=login
//

// Package login is a generated GoMock package.
package login

import (
	context "context"
	reflect "reflect"

	domain "github.com/nick6969/go-clean-project/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// Mockrepository is a mock of repository interface.
type Mockrepository struct {
	ctrl     *gomock.Controller
	recorder *MockrepositoryMockRecorder
	isgomock struct{}
}

// MockrepositoryMockRecorder is the mock recorder for Mockrepository.
type MockrepositoryMockRecorder struct {
	mock *Mockrepository
}

// NewMockrepository creates a new mock instance.
func NewMockrepository(ctrl *gomock.Controller) *Mockrepository {
	mock := &Mockrepository{ctrl: ctrl}
	mock.recorder = &MockrepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockrepository) EXPECT() *MockrepositoryMockRecorder {
	return m.recorder
}

// FindUserByEmail mocks base method.
func (m *Mockrepository) FindUserByEmail(ctx context.Context, email string) (*domain.DBUserModel, *domain.GPError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindUserByEmail", ctx, email)
	ret0, _ := ret[0].(*domain.DBUserModel)
	ret1, _ := ret[1].(*domain.GPError)
	return ret0, ret1
}

// FindUserByEmail indicates an expected call of FindUserByEmail.
func (mr *MockrepositoryMockRecorder) FindUserByEmail(ctx, email any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByEmail", reflect.TypeOf((*Mockrepository)(nil).FindUserByEmail), ctx, email)
}

// Mockpassword is a mock of password interface.
type Mockpassword struct {
	ctrl     *gomock.Controller
	recorder *MockpasswordMockRecorder
	isgomock struct{}
}

// MockpasswordMockRecorder is the mock recorder for Mockpassword.
type MockpasswordMockRecorder struct {
	mock *Mockpassword
}

// NewMockpassword creates a new mock instance.
func NewMockpassword(ctrl *gomock.Controller) *Mockpassword {
	mock := &Mockpassword{ctrl: ctrl}
	mock.recorder = &MockpasswordMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockpassword) EXPECT() *MockpasswordMockRecorder {
	return m.recorder
}

// Compare mocks base method.
func (m *Mockpassword) Compare(hashed, password string) *domain.GPError {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Compare", hashed, password)
	ret0, _ := ret[0].(*domain.GPError)
	return ret0
}

// Compare indicates an expected call of Compare.
func (mr *MockpasswordMockRecorder) Compare(hashed, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Compare", reflect.TypeOf((*Mockpassword)(nil).Compare), hashed, password)
}

// Mocktoken is a mock of token interface.
type Mocktoken struct {
	ctrl     *gomock.Controller
	recorder *MocktokenMockRecorder
	isgomock struct{}
}

// MocktokenMockRecorder is the mock recorder for Mocktoken.
type MocktokenMockRecorder struct {
	mock *Mocktoken
}

// NewMocktoken creates a new mock instance.
func NewMocktoken(ctrl *gomock.Controller) *Mocktoken {
	mock := &Mocktoken{ctrl: ctrl}
	mock.recorder = &MocktokenMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocktoken) EXPECT() *MocktokenMockRecorder {
	return m.recorder
}

// GenerateAccessToken mocks base method.
func (m *Mocktoken) GenerateAccessToken(userID int) (string, *domain.GPError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateAccessToken", userID)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(*domain.GPError)
	return ret0, ret1
}

// GenerateAccessToken indicates an expected call of GenerateAccessToken.
func (mr *MocktokenMockRecorder) GenerateAccessToken(userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateAccessToken", reflect.TypeOf((*Mocktoken)(nil).GenerateAccessToken), userID)
}
